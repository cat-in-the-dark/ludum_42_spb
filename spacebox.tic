-- title:  game title
-- author: game developer
      -- desc:   short description
-- script: lua

T=8
W=240
H=136

Player = {
  x=0,
  y=0,
  cr={x=0,y=0,w=8,h=16},
  vx=0,
  vy=0,
  rigid=true,
  mass=true,
  sp={{256},{272}}
}

cam={x=W//2,y=H//2}

SpikeTex = {
  C=304,
  L=305,
  U=306,
  D=307,
  R=308
}

function deepcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepcopy(orig_key)] = deepcopy(orig_value)
        end
        setmetatable(copy, deepcopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

LSpikes = {
  x=0,
  y=0,
  vx=0,
  vy=0,
  cr={x=0,y=0,w=240,h=136},
  rigid=false,
  mass=false,
  sp={}
}

Flag = {
  x=16,
  y=192,
  cr={x=0,y=0,w=8,h=48},
  sp={{6,1},{22,23},{38,39},{54,1},{54,1},{54,1}}
}

RSpikes = deepcopy(LSpikes)
USpikes = deepcopy(LSpikes)
DSpikes = deepcopy(LSpikes)

function drawEnt(e,cam)
  local i=1
  for i,t in ipairs(e.sp) do
    for j,v in ipairs(t) do
      spr(v, e.x+(j-1)*T+cam.x, e.y+(i-1)*T+cam.y, 0)
    end
  end
end

function vec2(xV, yV)
  return {x=xV,y=yV}
end

function v2mul(v, s)
  return vec2(v.x*s, v.y*s)
end

function v2div(v,s)
  return vec2(v.x/s, v.y/s)
end

function v2add(v1, v2)
  return vec2(v1.x+v2.x,v1.y+v2.y)
end

function v2len(v)
  return math.ceil(math.sqrt(v.x*v.x + v.y*v.y))
end

function sign(x) return x>0 and 1 or x<0 and -1 or 0 end
function lerp(a,b,t) return (1-t)*a + t*b end

BTN_UP = 0
BTN_LEFT = 2
BTN_RIGHT = 3

JMP_IMP = 3
ACCEL = 0.2

transparent_sprites_index = 0
solid_sprites_index = 80
bonus_index = 112

function isTileRemovable(tile)
    return tile == 82 or tile == 83
end

function isTileBouns(x,y)
  return mget(x,y) >= bonus_index
end

function IsTileSolid(x, y)
  tileId = mget(x, y)
  if triggerBonus and isTileRemovable(tileId) then
    return false
  end
  return (tileId >= solid_sprites_index)
end

function getMapRange()
  return triggerBonus and 34 or 17
end

function collide(e1,e2)
  return (e1.x < e2.x+e2.cr.w and e2.x < e1.x + e1.cr.w) and
    (e1.y < e2.y+e2.cr.h and e2.y < e1.y+e1.cr.h)
end

function handleInput()
  local iv={pos=vec2(0,0), jump=false}
  if btn(BTN_LEFT) then
    iv.pos.x = -1
  elseif btn(BTN_RIGHT) then
    iv.pos.x = 1
  end
  if btn(BTN_UP) then
    iv.jump=true
  end
  return iv
end

function CanMove(dp,cr)
  local x1 = dp.x + cr.x
  local y1 = dp.y + cr.y
  local x2 = x1 + cr.w - 1
  local y2 = y1 + cr.h - 1
  -- check all tiles touched by the rect
  local startC = x1 // T
  local endC = x2 // T
  local startR = y1 // T
  local endR = y2 // T
  -- print(string.format("%d %d %d %d", startC, endC, startR, endR), 0, 0, 4)
  if startR > mapRange then return true end
  for c = startC, endC do
    for r = startR, endR do
      if IsTileSolid(c, r) then
        -- TODO: move this to separate check
        if (isTileBouns(c,r)) then
          triggerBonus = true
        end
        return false
      end
    end
  end
  return true
end

function isOnFloor(e)
  return not CanMove(vec2(e.x,e.y+1),e.cr)
end

function isUnderCeiling(e)
  return not CanMove(vec2(e.x,e.y-1),e.cr)
end

function TryMoveBy(e,dp)
  local pos=vec2(e.x, e.y)
  CM = ""
  if (e.rigid) then
    if dp.x ~= 0 then
      for i=dp.x,sign(dp.x),-1*sign(dp.x) do
        if CanMove(vec2(e.x+i,e.y),e.cr) then
          e.x=e.x+i
          break
        end
      end
    end
    if dp.y ~= 0 then
      if CanMove(vec2(e.x,e.y+dp.y),e.cr) then
        e.y=e.y+dp.y
      else
        moveby=0
        for i=0,math.ceil(dp.y),sign(dp.y) do
          if CanMove(vec2(e.x,e.y+i),e.cr) then
            moveby=i
          else
            break
          end
        end
        e.y=e.y+moveby
      end
    end
  else
    e.x=e.x+dp.x
    e.y=e.y+dp.y
  end
end

function update(e)
  local iv=handleInput()
  if (e.mass) then
    if isOnFloor(e) then
      if iv.jump then
        e.vy=-1*JMP_IMP
      else
        e.vy=0
      end
    elseif isUnderCeiling(e) and e.vy < 0 then
      e.vy=0
    else
      e.vy = e.vy + ACCEL
    end
  end
  local dp=v2add(iv.pos,vec2(e.vx, e.vy))
  TryMoveBy(e,dp)
end

function fillRect(e,x0,y0,w,h,tex)
  if e.sp == nil then e.sp = {} end
  for i=y0,h do
    if e.sp[i] == nil then e.sp[i]={} end
    for j=x0,w do
      e.sp[i][j]=tex
    end
  end
end

function updateCam(cam,e)
  cam.x=math.min(W//2,W//2-e.x)
  cam.y=math.min(H//2,H//2-e.y)
end

function updateSpikes()
  LSpikes.x = math.max(LSpikes.x + LSpikes.vx, Player.x-320)
  if (Player.x > 960) then
    LSpikes.vx = 0.75 + (0.25 * (Player.x - 960) / 960)
  else
    LSpikes.vx = 0.75
  end
  if triggerBonus then
    RSpikes.x = RSpikes.x + RSpikes.vx
    if (Player.x < 960) then
      RSpikes.vx = -0.8 + (0.2 * (960-Player.x) / 960)
    else
      RSpikes.vx = -0.8
    end
  end
end

function init()
  local cw = W//T
  local ch = H//T
  fillRect(LSpikes,1,1,cw,ch,SpikeTex.C)
  fillRect(RSpikes,1,1,cw,ch,SpikeTex.C)
  fillRect(USpikes,1,1,cw,ch,SpikeTex.C)
  fillRect(DSpikes,1,1,cw,ch,SpikeTex.C)
  fillRect(LSpikes,cw,1,cw,ch,SpikeTex.L)
  fillRect(RSpikes,1,1,1,ch,SpikeTex.R)
  fillRect(USpikes,1,ch,cw,ch,SpikeTex.U)
  fillRect(DSpikes,1,1,cw,1,SpikeTex.D)
  Player.x=64
  LSpikes.x=-240
  RSpikes.y=136
  RSpikes.x=1920
  triggerBonus = false
end

function TICFail()
  cls()
  print("Game over!", W/2-40, H/2, 4)
end

function TICWin()
  cls()
  print("You win!", W/2-32,H/2,4)
end

function TICGame()
  cls()
  updateCam(cam,Player)
  mapRange = getMapRange()
  map(0,0,W,mapRange + 34,cam.x,cam.y,-1,1, function(tile, x, y)
    if isTileRemovable(tile) and triggerBonus then
      return 1
    elseif y > mapRange then
      return 1
    end
    return tile
  end)
  update(Player)
  updateSpikes()
  drawEnt(Player,cam)
  print(string.format("%g %g %g %g", cam.x, cam.y, Player.x, Player.y), 0, 0, 4)
  drawEnt(LSpikes,cam)
  drawEnt(RSpikes,cam)
  if collide(Player, LSpikes) then mode=MOD_FAIL end
  if collide(Player, RSpikes) then mode=MOD_FAIL end
  if collide(Player, Flag) then mode=MOD_WIN end
  if Player.y//T > mapRange + 17 then mode=MOD_FAIL end
end

MOD_GAME = 0
MOD_FAIL = 1
MOD_WIN=2

TICMode={
  [MOD_GAME]=TICGame,
  [MOD_FAIL]=TICFail,
  [MOD_WIN]=TICWin
}

init()
mode=MOD_GAME
function TIC()
  TICMode[mode]()
end
